package command

import (
	"context"
	"errors"
)

// {{model}}CommandInterface contract for sending command to {{camelModel}} table
type {{model}}CommandInterface interface {
	Create(ctx context.Context, payload *data.PayloadCreate{{model}}) (*{{idDataType}}, error)
	Update(ctx context.Context, payload *data.PayloadUpdate{{model}}) (bool, error)
	Delete(ctx context.Context, id {{idDataType}}) (bool, error)
	ModelCreate(ctx context.Context, m *model.{{model}}) (*{{idDataType}}, error)
	ModelUpdate(ctx context.Context, m *model.{{model}}) (bool, error)
	ModelDelete(ctx context.Context, m *model.{{model}}) (bool, error)
}

type {{camelModel}}Command struct {
	repository repository.{{model}}RepositoryInterface
}

// Create is a function to create new {{model}} model and push it to database
func (c *{{camelModel}}Command) Create(ctx context.Context, payload *data.PayloadCreate{{model}}) (*{{idDataType}}, error) {
	m := model.{{model}}Model()

	{{modelFields}}

	return c.ModelCreate(ctx, m)
}

// Update is a function to update {{model}} model and push it to database
func (c *{{camelModel}}Command) Update(ctx context.Context, payload *data.PayloadUpdate{{model}}) (bool, error) {
    m, err := c.repository.Find(ctx, payload.Id)
	if nil != err {
		return false, err
	}
	if nil == m {
		return false, errors.New("{{camelModel}} not found")
	}

	{{modelFields}}

	return c.ModelUpdate(ctx, m)
}

// Delete is a function to delete {{camelModel}} by id
func (c *{{camelModel}}Command) Delete(ctx context.Context, id {{idDataType}}) (bool, error) {
	m, err := c.repository.Find(ctx, id)
	if nil != err {
		return false, err
	}
	if nil == m {
		return false, errors.New("{{camelModel}} not found")
	}

	return c.ModelDelete(ctx, m)
}

// ModelCreate create directly using given {{camelModel}}Model
func (c *{{camelModel}}Command) ModelCreate(ctx context.Context, m *model.{{model}}) (*{{idDataType}}, error) {
	return c.repository.Create(ctx, m)
}

// ModelUpdate update directly using given {{camelModel}}Model
func (c *{{camelModel}}Command) ModelUpdate(ctx context.Context, m *model.{{model}}) (bool, error) {
	return c.repository.Update(ctx, m)
}

// ModelDelete delete directly using given {{camelModel}}Model
func (c *{{camelModel}}Command) ModelDelete(ctx context.Context, m *model.{{model}}) (bool, error) {
	return c.repository.Delete(ctx, m)
}

// New{{model}}Command constructor of {{camelModel}} command
func New{{model}}Command() {{model}}CommandInterface {
	return &{{camelModel}}Command{
		repository: repository.New{{model}}Repository(),
	}
}
