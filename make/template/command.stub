package command

import (
	"context"
	"errors"
)

// {{.Model}}CommandInterface contract for sending command to {{.CamelModel}} table
type {{.Model}}CommandInterface interface {
	{{if .Action.Create}} Create(ctx context.Context, payload *data.PayloadCreate{{.Model}}) (*{{.DataType}}, error) {{end}}
	{{if .Action.Update}} Update(ctx context.Context, payload *data.PayloadUpdate{{.Model}}) (bool, error) {{end}}
	{{if .Action.Delete}} Delete(ctx context.Context, id {{.DataType}}) (bool, error) {{end}}
	{{if .Action.Create}} ModelCreate(ctx context.Context, m *model.{{.Model}}) (*{{.DataType}}, error) {{end}}
	{{if .Action.Update}} ModelUpdate(ctx context.Context, m *model.{{.Model}}) (bool, error) {{end}}
	{{if .Action.Delete}} ModelDelete(ctx context.Context, m *model.{{.Model}}) (bool, error) {{end}}
}

type {{.CamelModel}}Command struct {
	repository repository.{{.Model}}RepositoryInterface
}

{{if .Action.Create}}
// Create is a function to create new {{.Model}} model and push it to database
func (c *{{.CamelModel}}Command) Create(ctx context.Context, payload *data.PayloadCreate{{.Model}}) (*{{.DataType}}, error) {
	m := model.{{.Model}}Model()

	{{range .Fields}} {{printf "m.%s = payload.%s\n" .PascalName .PascalName}} {{end}}

	return c.ModelCreate(ctx, m)
}
{{end}}
{{if .Action.Update}}
// Update is a function to update {{.Model}} model and push it to database
func (c *{{.CamelModel}}Command) Update(ctx context.Context, payload *data.PayloadUpdate{{.Model}}) (bool, error) {
    m, err := c.repository.Find(ctx, payload.Id)
	if nil != err {
		return false, err
	}
	if nil == m {
		return false, errors.New("{{.CamelModel}} not found")
	}

	{{range .Fields}} {{printf "m.%s = payload.%s\n" .PascalName .PascalName}} {{end}}

	return c.ModelUpdate(ctx, m)
}
{{end}}
{{if .Action.Delete}}
// Delete is a function to delete {{.CamelModel}} by id
func (c *{{.CamelModel}}Command) Delete(ctx context.Context, id {{.DataType}}) (bool, error) {
	m, err := c.repository.Find(ctx, id)
	if nil != err {
		return false, err
	}
	if nil == m {
		return false, errors.New("{{.CamelModel}} not found")
	}

	return c.ModelDelete(ctx, m)
}
{{end}}
{{if .Action.Create}}
// ModelCreate create directly using given {{.CamelModel}}Model
func (c *{{.CamelModel}}Command) ModelCreate(ctx context.Context, m *model.{{.Model}}) (*{{.DataType}}, error) {
	return c.repository.Create(ctx, m)
}
{{end}}
{{if .Action.Update}}
// ModelUpdate update directly using given {{.CamelModel}}Model
func (c *{{.CamelModel}}Command) ModelUpdate(ctx context.Context, m *model.{{.Model}}) (bool, error) {
	return c.repository.Update(ctx, m)
}
{{end}}
{{if .Action.Delete}}
// ModelDelete delete directly using given {{.CamelModel}}Model
func (c *{{.CamelModel}}Command) ModelDelete(ctx context.Context, m *model.{{.Model}}) (bool, error) {
	return c.repository.Delete(ctx, m)
}
{{end}}

// New{{.Model}}Command constructor of {{.CamelModel}} command
func New{{.Model}}Command() {{.Model}}CommandInterface {
	return &{{.CamelModel}}Command{
		repository: repository.New{{.Model}}Repository(),
	}
}
